import customtkinter
import subprocess
import json
import os
import re
from PIL import Image, ImageTk
from CTkMessagebox import CTkMessagebox
import ipaddress
import socket

# Empêche la résolution automatique de Windows
customtkinter.deactivate_automatic_dpi_awareness()

# Chemin des images et des fichiers
icon_path = os.path.join("penautomate_images", "penautomate.ico")
back_path = os.path.join("penautomate_menu", "pentestreport", "pentestreportreco.py")
next_path = os.path.join("penautomate_menu", "pentestreport", "pentestreportexploit.py")
json2_path = os.path.join("penautomate_menu", "pentestreport", "pentestdata.json")
scan_path = os.path.join("penautomate_menu", "pentestreport", "tools", "networkscanner.py")

# Fenêtre root
root = customtkinter.CTk()
root.geometry("600x750")
root.title("PenAutomate")
root.iconbitmap(icon_path)
root.resizable(width=False, height=False)

# Centre la fenêtre au lancement
root.update_idletasks()
screen_width = root.winfo_screenwidth()
screen_height = root.winfo_screenheight()

window_width = root.winfo_width()
window_height = root.winfo_height()

x_pos = (screen_width - window_width) // 2
y_pos = (screen_height - window_height) // 2

root.geometry("+{}+{}".format(x_pos, y_pos))    

# Importe la configuration du thème Light / Dark depuis le fichier themes.json
with open('themes.json', 'r') as file:
    config = json.load(file)

# Apparence du thème
customtkinter.set_appearance_mode(config["appearance_mode"])
customtkinter.set_default_color_theme("dark-blue")

# Fonctions du menu
# NEXT
def next():
    # Charger les données depuis pentestdata.json
    with open(json2_path, 'r') as file:
        data = json.load(file)

    ips = [data.get('IP1'), data.get('IP2'), data.get('IP3')]  # Liste des IPs
    ips = [ip for ip in ips if ip]  # Filtrer pour enlever les None

    # Vérifier si au moins une IP est renseignée
    if not ips:
        CTkMessagebox(title="Erreur", message="Veuillez renseigner au moins une adresse IP")
        return

    # Pinger chaque IP et vérifier la connectivité
    unreachable_ips = []
    for ip in ips:
        # Ajuster la commande pour Windows
        response = subprocess.run(['ping', '-n', '1', '-w', '1000', ip], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        # Vérifier si "TTL=" est présent dans la sortie, ce qui indique un succès
        if "TTL=" not in response.stdout:
            unreachable_ips.append(ip)
    
    if unreachable_ips:
        error_message = "Assurez-vous de bien pouvoir contacter les machines suivantes: " + ", ".join(unreachable_ips)
        CTkMessagebox(title="Erreur de connectivité", message=error_message)
        return

    # Si toutes les IP sont pingables, passer au script suivant
    root.destroy()
    subprocess.run(["python", next_path])

# BACK
def back():
    root.destroy()
    subprocess.run(["python", back_path])    

# Frame du menu
frame = customtkinter.CTkFrame(master=root)
frame.pack(fill="y", expand=True, side="top")

# Titre de la frame
label = customtkinter.CTkLabel(master=frame, text="\U0001f47e   Scanning Networks   \U0001f47e", font=("Lato", 24, "bold"))
label.pack(pady=12, padx=10)

label = customtkinter.CTkLabel(master=frame, text="Check active systems and open ports. Identify services running on active systems. Perform operating system banner/fingerprint capture. Identify network vulnerabilities", font=("Lato", 10, "bold"), wraplength=400)
label.pack()

# Séparateur
label = customtkinter.CTkButton(master=frame, text="", width=550, hover=False, height=10, fg_color="#333")
label.pack(pady=10, padx=10, anchor="center")

label2 = customtkinter.CTkLabel(master=frame, text="Enter IP Addresses to scan :", font=("Lato", 16, "bold"))
label2.pack(pady=10, padx=10, anchor="w")

# Charger les données depuis pentestdata.json
with open(json2_path, 'r') as file:
    data = json.load(file)

# Entry fields for IP addresses
ip1_entry = customtkinter.CTkEntry(master=frame, placeholder_text=data.get('IP1', 'Enter IP1'))
ip2_entry = customtkinter.CTkEntry(master=frame, placeholder_text=data.get('IP2', 'Enter IP2'))
ip3_entry = customtkinter.CTkEntry(master=frame, placeholder_text=data.get('IP3', 'Enter IP3'))

ip1_entry.pack(pady=2)
ip2_entry.pack(pady=2)
ip3_entry.pack(pady=2)

def save_ips():
    # Obtenir les adresses IP des entrées
    ip1 = ip1_entry.get()
    ip2 = ip2_entry.get()
    ip3 = ip3_entry.get()

    # Vérifier si au moins une IP est renseignée
    if not (ip1 or ip2 or ip3):
        CTkMessagebox(title="Erreur", message="Veuillez renseigner au moins une adresse IP")
        return

    # Fonction pour valider les adresses IP
    def validate_ip(ip):
        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False

    # Valider et mettre à jour le fichier JSON si les IPs sont valides
    ips_to_save = {}
    for ip_key, ip_value in [('IP1', ip1), ('IP2', ip2), ('IP3', ip3)]:
        if ip_value:
            if validate_ip(ip_value):
                ips_to_save[ip_key] = ip_value
            else:
                CTkMessagebox(title="Erreur", message=f"L'adresse {ip_value} n'est pas valide.")
                return

    # Mettre à jour le dictionnaire des données avec les nouvelles IP ou ajouter des champs si nécessaire
    data.update(ips_to_save)

    # Sauvegarder les données modifiées dans le fichier JSON
    with open(json2_path, 'w') as file:
        json.dump(data, file, indent=4)

    # Afficher un message de confirmation si des IP ont été sauvegardées
    if ips_to_save:
        CTkMessagebox(title="Succès", message="Adresses IP sauvegardées avec succès")
    else:
        CTkMessagebox(title="Information", message="Aucune nouvelle adresse IP valide à sauvegarder.")
         
def refresh_placeholders():
    # Charger les données depuis pentestdata.json
    with open(json2_path, 'r') as file:
        data = json.load(file)

    # Détruire les entrées existantes s'ils existent
    global ip1_entry, ip2_entry, ip3_entry
    if 'ip1_entry' in globals():
        ip1_entry.destroy()
    if 'ip2_entry' in globals():
        ip2_entry.destroy()
    if 'ip3_entry' in globals():
        ip3_entry.destroy()

    # Recréer les entrées avec les nouveaux placeholders
    ip1_entry = customtkinter.CTkEntry(master=frame, placeholder_text=data.get('IP1', 'Enter IP1'))
    ip2_entry = customtkinter.CTkEntry(master=frame, placeholder_text=data.get('IP2', 'Enter IP2'))
    ip3_entry = customtkinter.CTkEntry(master=frame, placeholder_text=data.get('IP3', 'Enter IP3'))

    ip1_entry.pack(after=label2, pady=2)
    ip2_entry.pack(after=ip1_entry, pady=2)
    ip3_entry.pack(after=ip2_entry, pady=2)


# Function to clear all IP addresses from the JSON file
def clear_ips():
    if os.path.exists(json2_path):
        with open(json2_path, "r+") as file:
            data = json.load(file)
            keys_to_remove = ['IP1', 'IP2', 'IP3']
            for key in keys_to_remove:
                data.pop(key, None)
            file.seek(0)
            file.truncate()  # Clear the file before writing back the modified data
            json.dump(data, file, indent=4)
            CTkMessagebox(title="Cleared", message="IPs cleared", icon="check")

def use_scanned_ip():
    selected_ip_info = root.result_combobox.get()
    # Utiliser une expression régulière pour extraire l'adresse IP
    match = re.search(r"IP: (\d+\.\d+\.\d+\.\d+)", selected_ip_info)
    if not match:
        CTkMessagebox(title="Erreur", message="Aucune adresse IP valide trouvée.")
        return

    selected_ip = match.group(1)
    
    # Charger les données depuis pentestdata.json
    with open(json2_path, 'r') as file:
        data = json.load(file)

    # Vérifier si l'IP sélectionnée est déjà dans le fichier JSON
    if selected_ip in (data.get('IP1', ''), data.get('IP2', ''), data.get('IP3', '')):
        CTkMessagebox(title="Info", message="IP déjà enregistrée")
        return

    # Trouver la première entrée IP disponible et l'ajouter
    for ip_key in ['IP1', 'IP2', 'IP3']:
        if not data.get(ip_key):  # Cherche une entrée vide
            data[ip_key] = selected_ip
            with open(json2_path, 'w') as file:
                json.dump(data, file, indent=4)
            CTkMessagebox(title="Succès", message=f"{selected_ip} enregistrée comme {ip_key}")
            return

    # Si toutes les IP sont remplies
    CTkMessagebox(title="Erreur", message="Trois IP ont déjà été renseignées")


# Créer un cadre dédié pour les boutons
button_frame = customtkinter.CTkFrame(master=frame)
button_frame.pack(pady=20)  # Ajuster le padding comme nécessaire        

# Bouton Refresh pour recharger les placeholders
refresh_button = customtkinter.CTkButton(master=button_frame, text="Refresh", command=refresh_placeholders, fg_color="#22B14C", hover_color="#1A873A")
refresh_button.pack(side="left", padx=10, pady=10)

# Save button
save_button = customtkinter.CTkButton(master=button_frame, text="Save IPs", command=save_ips)
save_button.pack(side="left", padx=10, pady=10)

# Clear IPs button
clear_button = customtkinter.CTkButton(master=button_frame, text="Clear IPs", command=clear_ips, fg_color="#A66520", hover_color="#8A541B")
clear_button.pack(side="left", padx=10, pady=10)

# Séparateur
label = customtkinter.CTkButton(master=frame, text="", width=550, hover=False, height=10, fg_color="#333")
label.pack(pady=10, padx=10, anchor="center")

label = customtkinter.CTkLabel(master=frame, text="Host Discovery in your Network (optional)", font=("Lato", 16, "bold"))
label.pack(pady=10, padx=10, anchor="w")

label = customtkinter.CTkLabel(master=frame, text="This tool enables host discovery to help you choose IP addresses to scan", font=("Lato", 14, "bold"))
label.pack(pady=10, padx=10, anchor="center")

# Additional functionality to scan the network
def scan_network():
    spacer_label.pack_forget()
    command = ['python', scan_path]
    result = subprocess.run(command, capture_output=True, text=True)
    output = result.stdout
    if result.returncode == 0:
        # Parsez les résultats si nécessaire
        result_list = output.split('\n')  # Exemple de division des résultats en lignes

        # Supprimez les anciens widgets s'ils existent déjà
        if hasattr(root, 'result_combobox'):
            root.result_combobox.destroy()
        if hasattr(root, 'use_button'):
            root.use_button.destroy()

        # Créez un CTkComboBox pour afficher les résultats
        root.result_combobox = customtkinter.CTkComboBox(master=frame, values=result_list, width=500, state="readonly")
        root.result_combobox.pack(after=scan_button, pady=5)
        
        # Créez et affichez le bouton Use
        root.use_button = customtkinter.CTkButton(master=frame, text="Use", command=use_scanned_ip)
        root.use_button.pack(after=root.result_combobox, pady=5)
    else:
        print("Erreur lors du scan du réseau")
        print(result.stderr)
  

# Button to trigger the network scan
scan_button = customtkinter.CTkButton(frame, text="Scan your network", command=scan_network)
scan_button.pack(pady=10)

# Ajout d'un label comme espaceur avec une hauteur minimale
spacer_label = customtkinter.CTkLabel(master=frame, height=70, text="")
spacer_label.pack()

# Progress bar
progressbar = customtkinter.CTkProgressBar(master=frame, width=500)
progressbar.pack(pady=10, padx=10)
progressbar.set(0.66)

# Séparateur
label = customtkinter.CTkButton(master=frame, text="", width=550, hover=False, height=10, fg_color="#333")
label.pack(pady=20, padx=10)

# BOUTON BACK
back_button = customtkinter.CTkButton(master=frame, text="Back", command=back, font=("Lato", 14, "bold"), fg_color="#22B14C", hover_color="#1A873A")
back_button.pack(side="left", padx=15)

# BOUTON NEXT
next_button = customtkinter.CTkButton(master=frame, text="Next", command=next, font=("Lato", 14, "bold"), fg_color="#22B14C", hover_color="#1A873A")
next_button.pack(side="right", padx=15)


# Main Loop
root.mainloop()